/*
 	static 변수(클래스 변수),  static 메소드(클래스 메소드) 
 	
 	인스턴스 변수(객체 변수), 인스턴스 메소드(객체 메소드) - static 안 붙은것들 
 
 	지역변수,
 	
 	static 초기화 블럭, 객체 생성시 메모리 로딩 및 호출 순서 
 
 
 주제 :  자바에서 클래스안의 멤버변수(static 을 붙이거나, 안붙인 모든 변수들)들 종류 알아보기 
 
 
 */

class Test{
	// 멤버변수 종류 2가지 
	// 1. 인스턴스 변수 ( 객체 변수 )
	//	- static 을 붙이지 않고 작성된 변수 
	//	- 새로운 객체메모리를 생성할 때마다... 객체메모리 내부에 개별적으로 할당 되는 변수 메모리 
	//  - 새로은 객체메모리가 생성될 때마다 JVM 의 HEAP영역의 객체메모리 안에  할당되는 변수 메모리 
	int x;
	
	
	// 2. 클래스 변수 ( 정적 변수 )
	//  - static 을 붙이고 작성된 변수.
	//  - class 파일이 JVM 메모리의 Method 영역에 올라가면서 class 파일 내부에 개별적으로 할당되는 변수메모리
	//  - class 파일 하나당 한번만 개별적으로 할당되는 변수메모리
	//  - 객체 메모리를 생성하지 않고도          클래스명.           으로 접근 가능한 변수메모리 
	//  - 생성된 여러 객체 메모리들이 공통으로 사용할 데이터를 저장하는데 사용되는 변수 메모리 
	static int y;
	
	// 생성자
	// 정수하나를 매개변수로 받아서  인스턴스 변수 x 와 클래스변수 y 에 각각 누적 
	public Test(int z) {
		this.x += z;
		Test.y += z;
		
	}
	
	
	
}



public class Ex1 {

	// static 을 붙여 만들어 놓은 main 메소드 또한 Ex1 클래스 내부에 만들어져 있는 클래스 메소드라고 할수 있다. 
	public static void main(String[] args) {
		
		// 1. 클래스변수 static int y 의 값을 불러와 출력 
		// 방법 : 객체 생성 없이 클래스명.클래스변수명 
		System.out.println("클래스명.클래스변수명 = " + Test.y); // 클래스명.클래스변수명 = 0
		
		// 2. 인스턴스변수 int x 를  객체 생성없이 클래스명.객체변수명 으로 접근 불가능 
		// System.out.println(Test.x);  컴파일 에러 발생 
		
		//3. 인스턴스 변수 x 의 값을  불러와 사용하려면 ?
		// 방법 : 객체 생성 후 참조변수명.인스턴스변수명 
		Test t1 = new Test(10);
		
		System.out.println("Test t1 객체");
		
		// 인스턴스 변수 x 의 값 불러와서 출력 
		System.out.println( "t1.x = "+ t1.x);	
		// 클래스변수 y 의 값 불러와서 출력 
//		System.out.println("Test.y = " + Test.y);
		System.out.println("t1.y = " + t1.y);
		
		// 클래스 변수값을 불러와 사용하려면?
		// 2가지 방법 
		// 방법1.  클래스명.클래스변수명 
		// 방법2. 객체 생성 후   참조변수명.클래스변수명 
		
		// --------------------------------------------------------------------------------	
		// --------------------------------------------------------------------------------	
		// --------------------------------------------------------------------------------	
		
		// Test 클래스의 객체 메모리 생성시 생성자로 10을 전달해 인스턴스변수 x 에 누적,  클래스변수 y 에 10을 누적 해보자 
		
		Test t2 = new Test(10);
		// 참고. new 연산자를 이용해 새로 생성한 Test 객체 메모리는 JVM 메모리의 Heap 영역에 따로 생성되어 개별적 메모리를 갖기 때문에 Test 객체 메모리 내부 또한
		//	 int x 인스턴스 변수도 개별적 메모리를 갖게 됨 
		
		System.out.println("Test t2 객체");
		
		// 인스턴스변수 x 에 저장된  값 불러와 출력 
		System.out.println( "t2.x = "+ t2.x); //10 
		// 클래스변수 y 에 저장된 값 불러와 출력 
		System.out.println("Test.y = " + Test.y); //20 
		
		/*
		 	결론 
		 			출력결과를 보면 static 으로 선언된 클래스 변수 y는?
		 			클래스 하나만 하나의 클래스변수만 JVM 메모리에 올라가서 생성되므로 
		 			위의 t1, t2 참조변수의 객체가 클래스 변수 y를 하나 공유받아 사용하므로 
		 			클래스 변수 y 의 값이 계속 += 10 누적된다고 보면 된다.
		 			
		 			출력 결과를 보면 객체를  생성할때  객체 메모리 내부에 만들어지는 x 변수는?
		 			객체를 생성할때마다 각각의 객체 메모리에 각각 개별로 JVM메모리의 heap 영역의  x  인스턴스변수 메모리가 생성됨 
		 			그러므로 각각  x 인스터스 변수 2개는 각각 += 에의해 10이 저장됨 
		 			
		 			
		 */
		
		
		
		
	}

}
